#![feature(generic_const_exprs)]
use std::{thread::sleep, time::Duration, usize};

use itertools::{iproduct, Itertools};
use rand::Rng;

type Game<const M: usize, const N: usize> = [[bool; M]; N];

trait GameOfLife<const M: usize, const N: usize> {
    fn live_next(&self, x: isize, y: isize) -> bool;
    fn next_game(&mut self);
    fn print_game_hexagon(&self) where [(); M * 2 - 1]:;
    fn print_game(&self) where [(); M * 2 - 1]:;
    fn init_rand(&mut self);
}

impl<const M: usize, const N: usize> GameOfLife<M, N> for Game<M, N> {
    fn live_next(&self, x: isize, y: isize) -> bool {
        let mut count = 0;
        for (i, j) in iproduct!(-1..=1, -1..=1) {
            if i == 0 && j == 0 {
                continue;
            }
            let x = (x + i).rem_euclid(N as isize);
            let y = (y + j).rem_euclid(M as isize);;
            if x < 0 || y < 0 || x >= N as isize || y >= M as isize {
                continue;
            }
            count += self[x as usize][y as usize] as usize;
        }

        match self[x as usize][y as usize] {
            true => count == 2 || count == 3,
            false => count == 3,
        }
    }

    fn next_game(&mut self) {
        let temp = self.clone();
        for i in 0..N {
            for j in 0..M {
                self[i][j] = temp.live_next(i as isize, j as isize);
            }
        }
    }

    fn print_game_hexagon(&self) where [(); M * 2 - 1]: {
        let str: Vec<_> = self
            .into_iter()
            .map(|row| {
                row.into_iter()
                    .map(|val| match val {
                        true => "⬤",
                        false => " ",
                    })
                    .intersperse(" ")
                    .collect::<String>()
            })
            .collect();
        str.into_iter().enumerate().for_each(|(i, row)| {
            if i % 2 == 0 {
                println!("│ {row}│");
            } else {
                println!("│{row} │");
            }
        });
        let line: String = ['─'; M * 2].iter().collect();
        println!("├{}┤", line);
    }

    fn print_game(&self) where [(); M * 2 - 1]: {
        let str: Vec<_> = self
            .into_iter()
            .map(|row| {
                row.into_iter()
                    .map(|val| match val {
                        true => "⬤",
                        false => " ",
                    })
                    .intersperse(" ")
                    .collect::<String>()
            })
            .collect();
        str.into_iter().enumerate().for_each(|(i, row)| {
            println!("│{row}│");
        });
        let line: String = ['─'; M * 2 - 1].iter().collect();
        println!("├{}┤", line);
    }

    fn init_rand(&mut self) {
        let mut rng = rand::rng();
        for i in 0..N {
            for j in 0..M {
                self[i][j] = rng.random();
            }
        }
    }
}

fn main() {
    let mut game: Game<78, 42> = [[false; 78]; 42];
    game.init_rand();
    // let mut game: Game<40, 30> = [
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
    //     [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    //     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // ]
    // //let mut game: Game<10, 10> = [
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
    // //    [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    // //]
    // .map(|row| {
    //     row.map(|x| match x {
    //         0 => false,
    //         1 => true,
    //         _ => panic!(),
    //     })
    // });

    for _ in 0..usize::MAX {
        game.print_game_hexagon();
        game.next_game();
        sleep(Duration::from_millis(50));
    }
}
